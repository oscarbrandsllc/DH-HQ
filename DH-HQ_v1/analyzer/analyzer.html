<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sleeper League KTC Infographic</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;700&family=Product+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link href="../styles/styles.css?v=20250827002411?v=20250826235225" rel="stylesheet"/>
    <style>
        :root {
            --font-sans: 'Product Sans', 'Google Sans', 'Quicksand', sans-serif;
            --color-bg: #0D0E1B;
            --color-panel-border: rgba(128, 138, 189, 0.2);
            --color-text-primary: #EAEBF0;
            --color-text-secondary: #9096C0;
            --color-accent-primary: #766DFF;
            --color-accent-primary-glow: rgba(118, 109, 255, 0.5);
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            overflow-x: hidden;
        }

        #starfield {
            position: fixed; inset: 0; z-index: -10; pointer-events: none;
            background: radial-gradient(ellipse at 50% 100%, #1B2735 0%, #090A0F 100%);
        }

        #stars1, #stars2, #stars3 {
            position: absolute; left: 0; top: 0;
            background: transparent;
            animation: animStar linear infinite;
        }

        #stars1 { width: 1px; height: 1px; box-shadow: 1528px 425px #FFF, 1965px 1848px #FFF, 466px 588px #FFF, 1441px 1361px #FFF, 395px 1296px #FFF, 1603px 1631px #FFF, 1403px 1363px #FFF, 1010px 54px #FFF, 904px 1539px #FFF, 929px 1400px #FFF, 1370px 1286px #FFF, 612px 1109px #FFF, 1899px 1371px #FFF, 215px 873px #FFF, 1997px 882px #FFF, 283px 759px #FFF, 1675px 1005px #FFF, 145px 1973px #FFF, 1974px 1948px #FFF, 128px 1115px #FFF, 1863px 1335px #FFF, 1540px 938px #FFF, 1739px 491px #FFF, 1898px 1397px #FFF, 706px 1264px #FFF, 1505px 1162px #FFF, 200px 1889px #FFF, 1044px 1230px #FFF, 315px 1227px #FFF, 625px 217px #FFF, 1813px 1135px #FFF, 287px 791px #FFF, 1131px 816px #FFF, 845px 87px #FFF, 272px 94px #FFF, 1341px 1194px #FFF, 1547px 893px #FFF, 1460px 1971px #FFF, 655px 1052px #FFF, 1178px 815px #FFF, 1643px 1785px #FFF, 1172px 277px #FFF, 1486px 280px #FFF, 134px 1224px #FFF, 338px 213px #FFF, 814px 1844px #FFF, 1207px 806px #FFF, 14px 526px #FFF, 957px 455px #7300ff, 518px 864px #7300ff, 321px 438px #7300ff, 1226px 1328px #FFF, 784px 1010px #FF0266, 1052px 1568px #FF0266, 350px 478px #FF0266; animation-duration: 450s; }
        #stars2 { width: 2px; height: 2px; box-shadow: 444px 26px #FFF, 644px 550px #FFF, 428px 426px #FFF, 12px 1913px #FFF, 680px 225px #FFF, 1346px 474px #FFF, 6px 1693px #FFF, 1555px 996px #FFF, 579px 1620px #FFF, 364px 1911px #FFF, 282px 1788px #FFF, 280px 337px #FFF, 1880px 1547px #FF0266, 1531px 1567px #FF0266, 193px 1099px #FF0266, 1540px 17px #FF0266, 1774px 292px #FF0266, 183px 775px #FF0266, 214px 107px #FFF, 695px 88px #FFF, 490px 1209px #FFF, 1374px 560px #FFF, 752px 1759px #FFF, 1985px 866px #FFF, 609px 310px #FFF, 86px 1036px #FFF, 638px 191px #FFF, 1635px 626px #FFF, 78px 998px #FFF, 1189px 1345px #FFF, 48px 1383px #FFF, 1981px 345px #FFF, 1993px 1838px #FFF, 717px 1540px #FFF, 287px 673px #FFF, 1821px 1665px #FFF, 686px 600px #FFF, 572px 777px #FFF, 932px 537px #FFF, 1808px 1538px #FFF, 1563px 305px #FFF, 1771px 1974px #FFF, 393px 1768px #FFF, 368px 1426px #FFF, 434px 779px #FFF, 566px 1370px #FFF, 261px 791px #FFF, 141px 434px #1ACDD1; animation-duration: 400s; }
        #stars3 { width: 3px; height: 3px; box-shadow: 1208px 1620px #FF0070, 576px 1883px #FFF, 1810px 913px #FFF, 87px 1117px #FFF, 1076px 1851px #FFF, 859px 264px #FFF, 1469px 1346px #FFF, 1651px 1493px #FFF, 767px 822px #FFF, 359px 967px #FFF, 1009px 808px #FF0070, 100px 1656px #7300ff, 1365px 1511px #7300ff, 429px 1279px #7300ff, 1381px 1850px #E86439, 1896px 1999px #E86439, 236px 718px #7300ff, 39px 1731px #7300ff, 562px 1084px #7300ff, 1067px 1431px #FF0266, 1362px 1575px #FF0266, 953px 1860px #FF0266, 1498px 499px #FF0266, 1055px 885px #FFF, 1824px 1334px #FFF, 519px 1319px #FFF, 1716px 1538px #FFF, 1305px 524px #FFF, 808px 1972px #FFF, 426px 649px #FFF, 882px 1530px #FFF, 623px 557px #FFF, 129px 1750px #FF0070; animation-duration: 350s; }
        
        @keyframes animStar { from { transform: translateY(0px); } to { transform: translateY(-2000px); } }

        .glass-panel {
            background-color: rgba(13, 14, 35, 0.21);
            background-image: linear-gradient(rgba(255,255,255, 0.03), rgba(255,255,255, 0.03));
            backdrop-filter: blur(6px) saturate(120%) brightness(120%);
            border: 1px solid rgba(128, 138, 189, 0.2);
            border-radius: 10px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255, 0.05), 
                        inset 0 0 0 2px rgba(200,200,200, 0.025), 
                        0 10px 26px rgba(0,0,0, .22);
        }
        
        h1, h2, h3 {
            font-family: var(--font-sans);
            color: var(--color-text-primary);
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
        }
        h1 { font-weight: 700; }
        h2 { font-weight: 500; }
        h3 { font-weight: 500; }
        
        .chart-container {
            position: relative;
            height: 450px;
            width: 100%;
        }

        .power-grid-item h3 {
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: .8px;
            color: var(--color-text-primary);
            text-align: center;
            padding: 0.2rem 0;
            margin-bottom: 0.5rem;
            position: relative;
            border: 1px solid var(--color-panel-border);
            border-radius: 5px;
            backdrop-filter: saturate(114%) blur(1px);
            overflow: hidden;
        }

        .power-grid-item h3::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            pointer-events: none;
            background-color: rgba(20, 28, 58, 0.15);
            background-image: linear-gradient(rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0) 35%);
        }


        /* Fix for browser autofill styles */
        input:-webkit-autofill,
        input:-webkit-autofill:hover,
        input:-webkit-autofill:focus,
        input:-webkit-autofill:active {
            -webkit-box-shadow: 0 0 0 30px #0D0E1B inset !important; /* Match body bg */
            -webkit-text-fill-color: #c4c8ea !important;
            transition: background-color 5000s ease-in-out 0s;
            caret-color: #c4c8ea;
        }

        #usernameInput, #leagueSelect {
            background: linear-gradient(to bottom, rgba(0,0,0,0.01), rgba(0,0,0,0.1));
            border: 1px solid var(--color-panel-border);
            border-radius: 8px;
            backdrop-filter: blur(4px) saturate(110%);
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.05);
            color: #c4c8ea;
            transition: all 0.2s ease;
        }

        #usernameInput:focus, #leagueSelect:focus {
            outline: none;
            border-color: var(--color-accent-primary);
            box-shadow: 0 0 8px var(--color-accent-primary-glow);
        }

    </style>
</head>
<body data-page="analyzer" class="p-2 sm:p-4">
    <!-- Replaced Background: Starfield -->
    <div aria-hidden="true" id="starfield">
        <div id="stars1"></div>
        <div id="stars2"></div>
        <div id="stars3"></div>
    </div>
    <div id="noise-overlay"></div>
    <div class="relative z-10 content-wrapper">
        <div id="header-container">
            <header class="app-header glass-panel">
                <div class="header-row">
                    <div class="menu-container">
                        <button id="menu-button" class="menu-button">
                            <svg viewBox="0 0 100 80" width="20" height="20">
                                <rect width="100" height="15"></rect>
                                <rect y="30" width="100" height="15"></rect>
                                <rect y="60" width="100" height="15"></rect>
                            </svg>
                        </button>
                        <div id="dropdown-menu" class="dropdown-menu hidden">
                            <a href="../">Home</a>
                            <a href="#" id="menu-rosters">Rosters</a>
                            <a href="#" id="menu-ownership">Ownership</a>
                            <a href="#" id="menu-analyzer">League Analyzer</a>
                            <a href="#">Placeholder</a>
                        </div>
                    </div>
                    <div class="username-area">
                        <input autocapitalize="none" autocomplete="username" autocorrect="off" id="usernameInput" inputmode="text" name="username" placeholder="SLPR Username..." type="text" value="The_Oracle"/>
                    </div>
                    <div class="custom-select-wrapper">
                        <select id="leagueSelect" disabled>
                            <option>Select a league...</option>
                        </select>
                    </div>
                </div>
            </header>
        </div>
        <main class="container mx-auto" id="content">
            <div class="max-w-7xl mx-auto space-y-2 md:space-y-4">
                <!-- Page Header -->
                <header class="text-center space-y-2">
                    <h1 class="text-2xl md:text-3xl font-bold tracking-wider">Dynasty League Power Rankings</h1>
                    <p class="text-md text-gray-400">KTC Team Value Analysis</p>
                </header>

                <!-- Summary Stats -->
                <section id="summaryStats" class="hidden grid grid-cols-4 lg:grid-cols-8 gap-1 md:gap-4 text-center my-2 md:my-0">
            <!-- Summary boxes injected here -->
        </section>

        <!-- Loading Indicator -->
        <div id="loading" class="hidden text-center py-8">
            <p class="text-2xl animate-pulse">Analyzing cosmic data streams...</p>
        </div>

        <!-- Main Content -->
        <section id="infographicContent" class="hidden space-y-6">
            <!-- Top Level Charts -->
            <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="glass-panel p-2">
                    <h2 class="text-2xl text-center mb-4">Starting Lineup Value</h2>
                    <div class="chart-container">
                        <canvas id="startersValueChart"></canvas>
                    </div>
                </div>
                <div class="glass-panel p-2">
                    <h2 class="text-2xl text-center mb-4">Overall Team Value</h2>
                    <div class="chart-container">
                        <canvas id="overallValueChart"></canvas>
                    </div>
                </div>
            </section>
            
            <!-- Radar Chart -->
            <section class="glass-panel p-2">
                <h2 class="text-2xl text-center mb-4">Positional Strength</h2>
                <div class="chart-container">
                    <canvas id="radarChart"></canvas>
                </div>
            </section>

            <!-- Detailed Starter Rankings -->
            <section class="glass-panel p-6">
                <h2 class="text-2xl text-center mb-6">Starting Position Power Grid</h2>
                <div id="starterRankingsGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4">
                    <!-- Grid items will be injected here by JavaScript -->
                </div>
            </section>
        </section>
    </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const params = new URLSearchParams(window.location.search);
            const username = params.get('username');
            const leagueId = params.get('leagueId');

            // --- DOM Elements ---
            const usernameInput = document.getElementById('usernameInput');
            const leagueSelect = document.getElementById('leagueSelect');
            const loadingIndicator = document.getElementById('loading');
            const infographicContent = document.getElementById('infographicContent');
            const starterRankingsGrid = document.getElementById('starterRankingsGrid');
            const summaryStats = document.getElementById('summaryStats');


            // --- Chart instances ---
            let overallChart, startersChart, radarChart;

            // --- State ---
            let state = {
                userId: null,
                leagues: [],
                players: {},
                ktcOneQb: {},
                ktcSflx: {},
                currentLeagueId: null,
                isSuperflex: false,
                cache: {}
            };

            const POS_COLORS = {
                QB: 'rgba(255, 58, 117, 0.8)',
                RB: 'rgba(0, 235, 199, 0.8)',
                WR: 'rgba(88, 167, 255, 0.8)',
                TE: 'rgba(180, 105, 255, 0.8)',
                FLEX: 'rgba(255, 127, 80, 0.8)', // Coral
                SUPER_FLEX: 'rgba(220, 220, 220, 0.8)', // Silver
                Picks: 'rgba(255, 199, 0, 0.8)'
            };


            // --- Event Listeners ---
            usernameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleFetchData();
                }
            });
            leagueSelect.addEventListener('change', () => {
                if (leagueSelect.value) {
                    analyzeLeague(leagueSelect.value);
                }
            });

            if (username) {
                usernameInput.value = username;
                handleFetchData();
            }

            async function handleFetchData() {
                const username = usernameInput.value.trim();
                if (!username) {
                    alert('Please enter a Sleeper username.');
                    return;
                }

                setLoading(true);
                infographicContent.classList.add('hidden');
                summaryStats.classList.add('hidden');

                try {
                    // Fetch all initial data concurrently
                    await Promise.all([
                        fetchSleeperPlayers(),
                        fetchKTCData()
                    ]);
                    
                    await fetchUserAndLeagues(username);

                    if (state.leagues.length > 0) {
                        if (leagueId) {
                            const leagueExists = state.leagues.some(l => l.league_id === leagueId);
                            if (leagueExists) {
                                leagueSelect.value = leagueId;
                                await analyzeLeague(leagueId);
                            } else {
                                alert('The specified league was not found for this user.');
                                setLoading(false);
                            }
                        } else {
                            // Auto-select and analyze the first league
                            leagueSelect.selectedIndex = 1;
                            await analyzeLeague(state.leagues[0].league_id);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching data:', error);
                    alert(`An error occurred: ${error.message}`);
                } finally {
                    setLoading(false);
                }
            }

            // --- Data Fetching ---
            async function fetchWithCache(url) {
                if (state.cache[url]) return state.cache[url];
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API request failed: ${response.statusText}`);
                const data = await response.json();
                state.cache[url] = data;
                return data;
            }

            async function fetchSleeperPlayers() {
                if (Object.keys(state.players).length > 0) return;
                state.players = await fetchWithCache('https://api.sleeper.app/v1/players/nfl');
            }

            async function fetchKTCData() {
                if (Object.keys(state.ktcOneQb).length > 0) return;
                const GOOGLE_SHEET_ID = '1MDTf1IouUIrm4qabQT9E5T0FsJhQtmaX55P32XK5c_0';
                try {
                    const [oneQbCsv, sflxCsv] = await Promise.all([
                        fetch(`https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?tqx=out:csv&sheet=KTC_1QB`).then(res => {
                            if (!res.ok) throw new Error('Failed to fetch 1QB KTC data: ' + res.statusText);
                            return res.text();
                        }),
                        fetch(`https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?tqx=out:csv&sheet=KTC_SFLX`).then(res => {
                            if (!res.ok) throw new Error('Failed to fetch SFLX KTC data: ' + res.statusText);
                            return res.text();
                        })
                    ]);
                    state.ktcOneQb = parseSheetData(oneQbCsv);
                    state.ktcSflx = parseSheetData(sflxCsv);
                } catch (error) {
                     console.error("KTC Fetch Error:", error);
                     throw new Error("Could not retrieve KTC valuation data. The proxy service may be down. Please try again later.");
                }
            }
            
            function parseSheetData(csvText) {
                const dataMap = {};
                const lines = csvText.split(/\r?\n/).slice(1);
                lines.forEach(line => {
                    const columns = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
                    if (columns.length < 13) return;
                    const clean = (str) => str ? str.replace(/"/g, '').trim() : '';
                    const pos = clean(columns[2]);
                    const sleeperId = clean(columns[12]);
                    const ktcValue = parseInt(clean(columns[6]), 10);

                    if (pos === 'RDP') {
                        const pickName = clean(columns[1]);
                        if (pickName) dataMap[pickName] = { ktc: ktcValue };
                    } else if (sleeperId && sleeperId !== 'NA') {
                        dataMap[sleeperId] = { ktc: isNaN(ktcValue) ? 0 : ktcValue };
                    }
                });
                return dataMap;
            }

            async function fetchUserAndLeagues(username) {
                const user = await fetchWithCache(`https://api.sleeper.app/v1/user/${username}`);
                if (!user || !user.user_id) throw new Error('Sleeper user not found.');
                state.userId = user.user_id;

                const leagues = await fetchWithCache(`https://api.sleeper.app/v1/user/${state.userId}/leagues/nfl/${new Date().getFullYear()}`);
                if (!leagues || leagues.length === 0) throw new Error('No active leagues found for this user in the current season.');
                state.leagues = leagues.sort((a,b) => a.name.localeCompare(b.name));

                populateLeagueSelect(state.leagues);
            }

            async function analyzeLeague(leagueId) {
                setLoading(true);
                infographicContent.classList.add('hidden');
                state.currentLeagueId = leagueId;

                const leagueInfo = state.leagues.find(l => l.league_id === leagueId);
                const qbSlots = leagueInfo.roster_positions.filter(p => p === 'QB').length;
                const superflexSlots = leagueInfo.roster_positions.filter(p => p === 'SUPER_FLEX').length;
                state.isSuperflex = qbSlots > 1 || superflexSlots > 0;

                const [rosters, users, tradedPicks] = await Promise.all([
                    fetchWithCache(`https://api.sleeper.app/v1/league/${leagueId}/rosters`),
                    fetchWithCache(`https://api.sleeper.app/v1/league/${leagueId}/users`),
                    fetchWithCache(`https://api.sleeper.app/v1/league/${leagueId}/traded_picks`)
                ]);

                const teams = processLeagueData(rosters, users, tradedPicks, leagueInfo);
                
                infographicContent.classList.remove('hidden');
                summaryStats.classList.remove('hidden');
                
                renderSummaryStats(teams);
                renderCharts(teams);
                renderRadarChart(teams);
                renderStarterGrid(teams, leagueInfo);

                setLoading(false);
            }

            function processLeagueData(rosters, users, tradedPicks, leagueInfo) {
                const userMap = users.reduce((acc, user) => ({ ...acc, [user.user_id]: user }), {});

                return rosters.map(roster => {
                    const owner = userMap[roster.owner_id];
                    const teamName = owner?.display_name || `Team ${roster.roster_id}`;
                    
                    let topPlayer = { name: 'N/A', ktc: 0 };
                    const allPlayers = (roster.players || []).map(pId => {
                        const playerInfo = state.players[pId];
                        const ktc = getKtcValue(pId);
                        if (ktc > topPlayer.ktc) {
                            topPlayer = { name: (playerInfo && playerInfo.first_name) ? `${playerInfo.first_name[0]}. ${playerInfo.last_name}` : 'Unknown', ktc };
                        }
                        return { id: pId, pos: playerInfo?.position, ktc };
                    }).sort((a,b) => b.ktc - a.ktc);

                    const overallPositional = { QB: 0, RB: 0, WR: 0, TE: 0, Picks: 0 };
                    allPlayers.forEach(p => {
                        if (overallPositional.hasOwnProperty(p.pos)) {
                            overallPositional[p.pos] += p.ktc;
                        }
                    });
                    
                    getOwnedPicks(roster.roster_id, rosters, tradedPicks, leagueInfo).forEach(p => {
                        overallPositional.Picks += getKtcValue(p.label);
                    });

                    const startersPositional = { QB: 0, RB: 0, WR: 0, TE: 0, FLEX: 0, 'SUPER_FLEX': 0 };
                    const startersPlayerDetails = { QB: [], RB: [], WR: [], TE: [], FLEX: [], 'SUPER_FLEX': [] };
                    const startersValueByPosition = { QB: 0, RB: 0, WR: 0, TE: 0 };
                    const starterIds = roster.starters || [];
                    const rosterPositions = leagueInfo.roster_positions;
                    starterIds.forEach((pId, index) => {
                        const slot = rosterPositions[index];
                        const playerInfo = state.players[pId];
                        const ktc = getKtcValue(pId);
                        
                        // For stacked bar chart
                        if (startersPositional.hasOwnProperty(slot)) {
                            startersPositional[slot] += ktc;
                            startersPlayerDetails[slot].push({
                                name: (playerInfo && playerInfo.first_name) ? `${playerInfo.first_name[0]}. ${playerInfo.last_name}` : 'Unknown',
                                ktc: ktc
                            });
                        }

                        // For summary rank calculation
                        if (playerInfo && startersValueByPosition.hasOwnProperty(playerInfo.position)) {
                            startersValueByPosition[playerInfo.position] += ktc;
                        }
                    });
                    
                    const totalValue = Object.values(overallPositional).reduce((a, b) => a + b, 0);

                    return {
                        teamName,
                        totalValue,
                        startersValue: Object.values(startersPositional).reduce((a,b) => a+b, 0),
                        overallPositional,
                        startersPositional,
                        startersPlayerDetails,
                        startersValueByPosition,
                        roster,
                        topPlayer,
                        allPlayers,
                        isUserTeam: roster.owner_id === state.userId
                    };
                }).sort((a,b) => b.totalValue - a.totalValue);
            }

            function getOwnedPicks(rosterId, allRosters, tradedPicks, leagueInfo) {
                const currentYear = new Date().getFullYear();
                const all_picks = [];

                // 1. Generate all original picks for every team for the next 4 years
                for (const r of allRosters) {
                    for (let i = 1; i <= 4; i++) {
                        const season = currentYear + i;
                        for (let round = 1; round <= leagueInfo.settings.draft_rounds; round++) {
                            all_picks.push({
                                season: season.toString(),
                                round: round,
                                roster_id: r.roster_id, // Original owner
                                owner_id: r.roster_id    // Current owner (by default)
                            });
                        }
                    }
                }

                // 2. Account for trades
                tradedPicks.forEach(trade => {
                    const pickIndex = all_picks.findIndex(p =>
                        p.season === trade.season &&
                        p.round === trade.round &&
                        p.roster_id === trade.roster_id
                    );
                    if (pickIndex !== -1) {
                        all_picks[pickIndex].owner_id = trade.owner_id;
                    }
                });

                // 3. Filter for picks owned by the current roster
                return all_picks
                    .filter(p => p.owner_id === rosterId)
                    .sort((a, b) => a.season.localeCompare(b.season) || a.round - b.round)
                    .map(p => ({ ...p, label: `${p.season} Mid ${ordinal(p.round)}` }));
            }

            // --- UI Rendering ---
            function renderSummaryStats(teams) {
                const userTeam = teams.find(t => t.isUserTeam);
                if (!userTeam) {
                    summaryStats.classList.add('hidden');
                    return;
                }

                const sortedByStarters = [...teams].sort((a, b) => b.startersValue - a.startersValue);
                
                const totalRank = sortedByStarters.findIndex(t => t.isUserTeam) + 1;
                const starterRank = sortedByStarters.findIndex(t => t.isUserTeam) + 1;

                const positionsToRank = ['QB', 'RB', 'WR', 'TE'];
                const positionalRanks = {};
                positionsToRank.forEach(pos => {
                    const sorted = [...teams].sort((a,b) => b.startersValueByPosition[pos] - a.startersValueByPosition[pos]);
                    positionalRanks[pos] = sorted.findIndex(t => t.isUserTeam) + 1;
                });

                summaryStats.innerHTML = `
                    <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">Overall Rank</p>
                        <p class="text-lg font-bold" style="color: ${getRankColor(totalRank, teams.length)}">${totalRank}/${teams.length}</p>
                    </div>
                    <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">Starters KTC</p>
                        <p class="text-lg font-bold">${userTeam.startersValue.toLocaleString()}</p>
                    </div>
                    <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">Starters Rank</p>
                        <p class="text-lg font-bold" style="color: ${getRankColor(starterRank, teams.length)}">${starterRank}/${teams.length}</p>
                    </div>
                    <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">Top Player</p>
                        <p class="text-sm font-bold truncate">${userTeam.topPlayer.name}</p>
                        <p class="text-[10px] text-purple-400">${userTeam.topPlayer.ktc.toLocaleString()}</p>
                    </div>
                    <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">QB Rank</p>
                        <p class="text-lg font-bold" style="color: ${getRankColor(positionalRanks.QB, teams.length)}">${positionalRanks.QB}/${teams.length}</p>
                    </div>
                    <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">RB Rank</p>
                        <p class="text-lg font-bold" style="color: ${getRankColor(positionalRanks.RB, teams.length)}">${positionalRanks.RB}/${teams.length}</p>
                    </div>
                     <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">WR Rank</p>
                        <p class="text-lg font-bold" style="color: ${getRankColor(positionalRanks.WR, teams.length)}">${positionalRanks.WR}/${teams.length}</p>
                    </div>
                     <div class="glass-panel p-1 rounded-lg">
                        <p class="text-[10px] text-gray-400">TE Rank</p>
                        <p class="text-lg font-bold" style="color: ${getRankColor(positionalRanks.TE, teams.length)}">${positionalRanks.TE}/${teams.length}</p>
                    </div>
                `;
            }
            
            function renderCharts(teams) {
                const labels = teams.map(t => {
                    const name = t.teamName;
                    return name.length > 11 ? name.substring(0, 11) + '…' : name;
                });

                // Overall Chart
                const overallDatasets = Object.keys(teams[0].overallPositional).map(pos => ({
                    label: pos,
                    data: teams.map(t => t.overallPositional[pos]),
                    backgroundColor: POS_COLORS[pos]
                }));
                if(overallChart) overallChart.destroy();
                const overallMaxKtc = Math.max(...teams.map(t => t.totalValue));
                overallChart = new Chart(document.getElementById('overallValueChart'), {
                    type: 'bar',
                    data: { labels, datasets: overallDatasets },
                    options: chartOptions(null, overallMaxKtc)
                });

                // Starters Chart
                const sortedStarters = [...teams].sort((a, b) => b.startersValue - a.startersValue);
                const startersLabels = sortedStarters.map(t => t.teamName);
                const startersDatasets = ['QB', 'RB', 'WR', 'TE', 'FLEX', 'SUPER_FLEX'].map(pos => ({
                    label: pos,
                    data: sortedStarters.map(t => t.startersPositional[pos]),
                    backgroundColor: POS_COLORS[pos]
                }));
                
                const startersMaxKtc = Math.max(...sortedStarters.map(t => t.startersValue));

                if(startersChart) startersChart.destroy();
                startersChart = new Chart(document.getElementById('startersValueChart'), {
                    type: 'bar',
                    data: {
                        labels: sortedStarters.map(t => {
                            const name = t.teamName;
                            return name.length > 11 ? name.substring(0, 11) + '…' : name;
                        }),
                        datasets: startersDatasets
                    },
                    options: chartOptions(sortedStarters, startersMaxKtc) // Pass sorted teams and max value
                });
            }

            function renderRadarChart(teams) {
                const userTeam = teams.find(t => t.isUserTeam);
                if (!userTeam) return;

                const leagueAverages = { QB: 0, RB: 0, WR: 0, TE: 0 };
                const userValues = { QB: 0, RB: 0, WR: 0, TE: 0 };
                const positions = ['QB', 'RB', 'WR', 'TE'];

                positions.forEach(pos => {
                    let totalLeagueKTC = 0;
                    teams.forEach(team => {
                        const topTwoPlayers = team.allPlayers.filter(p => p.pos === pos).slice(0, 2);
                        totalLeagueKTC += topTwoPlayers.reduce((sum, player) => sum + player.ktc, 0);
                    });
                    leagueAverages[pos] = totalLeagueKTC / teams.length;

                    const userTopTwo = userTeam.allPlayers.filter(p => p.pos === pos).slice(0, 2);
                    userValues[pos] = userTopTwo.reduce((sum, player) => sum + player.ktc, 0);
                });
                
                if(radarChart) radarChart.destroy();
                radarChart = new Chart(document.getElementById('radarChart'), {
                    type: 'radar',
                    data: {
                        labels: positions,
                        datasets: [
                            {
                                label: 'Your Team (Top 2)',
                                data: Object.values(userValues),
                                fill: true,
                                backgroundColor: 'rgba(118, 109, 255, 0.4)',
                                borderColor: 'rgba(118, 109, 255, 1)',
                                pointBackgroundColor: 'rgba(118, 109, 255, 1)',
                                pointBorderColor: '#fff',
                            },
                            {
                                label: 'League Average (Top 2)',
                                data: Object.values(leagueAverages),
                                fill: true,
                                backgroundColor: 'rgba(66, 194, 255, 0.4)',
                                borderColor: 'rgba(66, 194, 255, 1)',
                                pointBackgroundColor: 'rgba(66, 194, 255, 1)',
                                pointBorderColor: '#fff',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        elements: {
                            line: {
                                borderWidth: 3
                            }
                        },
                        scales: {
                            r: {
                                angleLines: { color: 'rgba(255, 255, 255, 0.2)' },
                                grid: { color: 'rgba(255, 255, 255, 0.2)' },
                                pointLabels: {
                                    font: { size: 14, family: "'Orbitron', sans-serif" },
                                    color: '#EAEBF0'
                                },
                                ticks: {
                                    color: '#EAEBF0',
                                    backdropColor: 'rgba(0,0,0,0.5)',
                                    font: { family: "'Roboto', sans-serif" }
                                }
                            }
                        },
                        plugins: {
                             legend: {
                                position: 'top',
                                labels: { color: '#EAEBF0', font: { family: "'Roboto', sans-serif" } }
                            }
                        }
                    }
                });
            }

            function renderStarterGrid(teams, leagueInfo) {
                starterRankingsGrid.innerHTML = '';

                const starterPositions = {};
                leagueInfo.roster_positions.forEach(pos => {
                    if (['QB', 'RB', 'WR', 'TE', 'FLEX', 'SUPER_FLEX'].includes(pos)) {
                        starterPositions[pos] = (starterPositions[pos] || 0) + 1;
                    }
                });

                Object.entries(starterPositions).forEach(([slotPosition, count]) => {
                    for (let i = 0; i < count; i++) {
                        const slotIndex = i + 1;
                        const slotData = [];

                        teams.forEach(team => {
                            const starters = team.roster.starters || [];
                            const positions = leagueInfo.roster_positions;
                            let playerFound = false;
                            let currentSlotCount = 0;

                            for (let j = 0; j < starters.length; j++) {
                                if (positions[j] === slotPosition) {
                                    currentSlotCount++;
                                    if (currentSlotCount === slotIndex) {
                                        const playerId = starters[j];
                                        const playerInfo = state.players[playerId];
                                        const ktcValue = getKtcValue(playerId);
                                        slotData.push({
                                            teamName: team.teamName,
                                            playerName: (playerInfo && playerInfo.first_name) ? `${playerInfo.first_name} ${playerInfo.last_name}` : 'Empty Slot',
                                            ktcValue: ktcValue,
                                        });
                                        playerFound = true;
                                        break;
                                    }
                                }
                            }
                             if (!playerFound) {
                                slotData.push({ teamName: team.teamName, playerName: 'Empty Slot', ktcValue: 0 });
                            }
                        });

                        slotData.sort((a, b) => b.ktcValue - a.ktcValue);

                        const gridItem = document.createElement('div');
                        gridItem.className = 'glass-panel p-3';

                        let content = `<h3 class="text-lg font-bold text-center mb-2">${slotPosition.replace('_', ' ')} ${slotIndex}</h3><ul>`;
                        slotData.forEach((data, index) => {
                            const rank = index + 1;
                            const color = getRankColor(rank, teams.length);
                            content += `
                                <li class="flex justify-between items-center text-xs py-0.5 border-b border-gray-800/50 gap-2">
                                    <div class="flex items-center gap-2 w-3/5 min-w-0">
                                        <span class="font-bold w-6 flex-shrink-0" style="color: ${color};">${rank}.</span>
                                        <span class="truncate">${data.teamName}</span>
                                    </div>
                                    <div class="text-right flex-shrink-0 w-2/5">
                                        <span class="font-semibold" style="color: ${color};">${data.ktcValue.toLocaleString()}</span>
                                        <p class="text-xs text-gray-500 truncate">${data.playerName}</p>
                                    </div>
                                </li>
                            `;
                        });
                        content += '</ul>';
                        gridItem.innerHTML = content;
                        starterRankingsGrid.appendChild(gridItem);
                    }
                });
            }

            // --- Charting ---
            function chartOptions(teamsDataForTooltip = null, maxKtc = 0) {
                const tooltipOptions = {
                     backgroundColor: 'rgba(13, 14, 27, 0.9)',
                     titleFont: { family: "'Orbitron', sans-serif", size: 16 },
                     bodyFont: { family: "'Roboto', sans-serif", size: 12 },
                     footerFont: { family: "'Roboto', sans-serif", weight: 'bold' },
                     borderColor: 'rgba(118, 109, 255, 0.5)',
                     borderWidth: 1,
                     padding: 10,
                     callbacks: {}
                };

                if (teamsDataForTooltip) {
                    tooltipOptions.callbacks.footer = (tooltipItems) => {
                        const teamIndex = tooltipItems[0].dataIndex;
                        const positionLabel = tooltipItems[0].dataset.label;
                        const teamData = teamsDataForTooltip[teamIndex];
                        
                        if (teamData && teamData.startersPlayerDetails && teamData.startersPlayerDetails[positionLabel]) {
                            const players = teamData.startersPlayerDetails[positionLabel];
                            return players
                                .sort((a, b) => b.ktc - a.ktc)
                                .slice(0, 3)
                                .map(p => `${p.name}: ${p.ktc.toLocaleString()}`)
                                .join('\n');
                        }
                        return '';
                    };
                }

                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    layout: {
                        padding: {
                            left: 0,
                            right: 5 
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: { 
                                color: '#EAEBF0', 
                                font: { 
                                    family: "'Roboto', sans-serif"
                                 },
                                 maxRotation: 45,
                                 minRotation: 45,
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            max: Math.ceil(maxKtc / 10000) * 10000,
                        },
                        y: {
                            stacked: true,
                            ticks: { 
                                color: '#EAEBF0', 
                                font: { 
                                    family: "'Roboto', sans-serif",
                                    size: 10
                                 },
                                 callback: function(value, index, values) {
                                    const label = this.getLabelForValue(value);
                                    // The label is already truncated before being passed to the chart data
                                    return label;
                                }
                            },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: '#EAEBF0', font: { family: "'Roboto', sans-serif" } }
                        },
                        tooltip: tooltipOptions
                    }
                };
            }
            
            // --- KTC & Formatting Helpers ---
            function getKtcValue(id) {
                const ktcSource = state.isSuperflex ? state.ktcSflx : state.ktcOneQb;
                return ktcSource[id]?.ktc || 0;
            }

            function ordinal(i) {
                const j = i % 10, k = i % 100;
                if (j === 1 && k !== 11) return i + "st";
                if (j === 2 && k !== 12) return i + "nd";
                if (j === 3 && k !== 13) return i + "rd";
                return i + "th";
            }

            function getRankColor(rank, total) {
                const percentile = (total - rank + 1) / total;
                if (percentile >= 0.8) return '#00EBC7'; // Top 20%
                if (percentile >= 0.6) return '#58A7FF';
                if (percentile >= 0.4) return '#EAEBF0';
                if (percentile >= 0.2) return '#FF7F50';
                return '#FF3A75'; // Bottom 20%
            }

            // --- UI Helpers ---
            function populateLeagueSelect(leagues) {
                leagueSelect.innerHTML = '<option value="">Select a league...</option>';
                leagues.forEach(league => {
                    const option = document.createElement('option');
                    option.value = league.league_id;
                    option.textContent = league.name;
                    leagueSelect.appendChild(option);
                });
                leagueSelect.disabled = false;
            }

            function setLoading(isLoading) {
                if (isLoading) {
                    loadingIndicator.classList.remove('hidden');
                } else {
                    loadingIndicator.classList.add('hidden');
                }
            }
        });
    </script>
    <script defer src="../scripts/app.js?v=20250826235225"></script>
</body>
</html>



